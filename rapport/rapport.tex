\documentclass[10pt, a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{PERALE Thomas et RUSU George}
\rhead{INFO-F-203}

\usepackage{graphicx}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage[]{algorithm2e}
\usepackage{indentfirst}

\begin{document}
\title{Rapport projet d'algorithmique 2}
\author{PERALE Thomas (000408160)\\
        RUSU George (000407965)\\}
\date{le 1 décembre 2015}

\maketitle
\section{Introduction}
Dans un parking d'un centre commercial, Mademoiselle Goal désire sortir sa voiture le plus rapidement possible en exécutant le moins de man½uvre possible. Evidement le parking n'est pas vide, alors Mademoiselle Goal demande à ses amis les informaticien de l'aider. Notre but et de trouver sous forme de graphe (un noeud du graphe représente une configuration du parking) le plus court chemin (le moins de manoeuvre possible) afin d'aider Mademoiselle Goal à rentrer chez elle.

\section{Cas de base}
Notre parking est un tableau n x n dans lequel plusieurs voiture s'y trouve. Parmi ces voitures, la voiture de Mlle, qui a notamment l'indicatif "G". Dans ce tableau, chaque cases peut contenir une voiture, généralement une voiture occupe deux cases. Il faut savoir qu'une voiture peut avancer ou reculer selon son orientation (verticale ou horizontale) jusqu'a la limite du tableau. L'unique voiture qui a le droit de sortir du tableau est bien évidement la voiture Goal.

\indent Toutes les information nécessaire à l'algorithme sont dans un fichier que notre programme reçoit comme input grâce au argv.
Voici un exemple de fichier:
    \lstinputlisting{../test/test1.txt}
    Celui ci nous renseigne sur:
    \begin{itemize}
        \item La taille du parking.
        \item La position de la sortie.
        \item L'emplacement des voitures dans ce parking.
    \end{itemize}
    Toute ces informations vont être parsé pour pouvoir créer un parking initial, qui sera notre
    cas de base à partir duquel il va falloir trouver le plus court chemin.\\
    Conformément à l'énoncé, l'algorithme ne fonctionnera que dans les cas suivant:
        \begin{itemize}
        \item Le fichier d'input est correctement écrit (pas d'erreur dans celui-ci), de la même manière que dans l'exemple.
        \item La voiture goal se déplace horizontalement (la sortie est sur la
            droite ou la gauche).
        \item Il n'y a pas de voiture de taille 1 (car impossible de savoir si
            elle se déplace horizontalement ou verticalement).
        \item Pas de parking de taille 0 (car pas possible d'y mettre une
            voiture goal).
    \end{itemize}

\section{Exemple d'utilisation.}
Exemple d'exécution en utilisant l'exemple au dessus.

\begin{lstlisting}
+---+---+---+---+---+
|     V2  V2        |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
| G   G   V3  V4
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|                   |
+---+---+---+---+---+

+---+---+---+---+---+
| V2  V2            |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
| G   G   V3  V4
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|                   |
+---+---+---+---+---+

+---+---+---+---+---+
| V2  V2  V3        |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
| G   G       V4
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|                   |
+---+---+---+---+---+

+---+---+---+---+---+
| V2  V2  V3        |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
|     G   G   V4
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|                   |
+---+---+---+---+---+

+---+---+---+---+---+
| V2  V2  V3        |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
|     G   G
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|             V4    |
+---+---+---+---+---+

+---+---+---+---+---+
| V2  V2  V3        |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
|         G   G
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|             V4    |
+---+---+---+---+---+

+---+---+---+---+---+
| V2  V2  V3        |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
|             G   G
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|             V4    |
+---+---+---+---+---+
\end{lstlisting}

\section{Description de la résolution du problème.}
    Le problème va se faire en plusieurs étapes:
    \begin{enumerate}
        \item Générer toutes les configurations\footnote{Une configuration d'un
            parking est un parking dans lequel une voiture a changer de position.
            A chaque tour, une voiture bougera dans le parking, c'est pour cette raison qu'on parle de
            configuration différente.} de parking possible.
        \item Lors de cette génération, créer un graphe dans lequel chaque
            configurations nouvellement créé est lié à la configuration d'où elle vient.
        \item Une fois ces configurations générées, il suffit d'appliquer un algorithme de
            recherche du plus court chemin sur le graphe dont les noeud sont des configurations.
    \end{enumerate}

   Exemple\footnote{Les exemples sont créés à  partir de
    http://analogbit.com/software/puzzletools/ .} de graphe associé aux
    configurations lors d'une génération non exhaustive (on abouti à  deux
    situation gagnante).

    % \includegraphics[scale=0.2]{gen0.png} \newline
    % \newpage
    \begin{tikzpicture}
        [scale=.8,auto=left,every node/.style={circle,fill=blue!20}]
        \node (n0) at (1, 10) {\includegraphics[scale=0.15]{gen0.png}};
        \node (n1) at (4, 10) {\includegraphics[scale=0.15]{gen1.png}};
        \node (n2) at (7, 10) {\includegraphics[scale=0.15]{gen2.png}};
        \node (n3) at (10, 10) {\includegraphics[scale=0.15]{gen3.png}};
        % Premier win

        %Autre situation Ã  partir de n0
        \node (n4) at (1, 7) {\includegraphics[scale=0.13]{gen4.png}};
        \node (n5) at (2, 5) {\includegraphics[scale=0.13]{gen5.png}};
        \node (n6) at (4, 4) {\includegraphics[scale=0.13]{gen6.png}};
        \node (n7) at (7, 4) {\includegraphics[scale=0.13]{gen7.png}};
        \node (n8) at (10, 4) {\includegraphics[scale=0.13]{gen8.png}};
        \node (n9) at (13, 4) {\includegraphics[scale=0.13]{gen9.png}};

        \node (n10) at (13, 4) {\includegraphics[scale=0.13]{gen10.png}};

        \foreach \from/\to in {n0/n1, n1/n2, n2/n3, n0/n4, n4/n5, n5/n6, n6/n7,
        n7/n8, n8/n9}
        \draw (\from) -- (\to);
    \end{tikzpicture}

\subsection{Génération des configurations.}
    Pour générer l'ensemble des solutions, un algorithme de backtracking est
    utilisé. Celui-ci fait avancer ou reculer un maximum chaque voitures dans chaque configuration.
    \subsection{Recherche du plus court chemin.}
    Pour trouver le plus court chemin parmi ceux déjà générés, nous allons utiliser l'algorithme le plus
    évident: l'algorithme de Dijkstra.
    Or ici, nous avons un cas spécial de l'algorithme de Dijkstra car la distance entre chaque noeuds est de 1,or l'algorithme de Dijkstra fait une recherche dans un graphe dans lequel la distance entre deux noeuds est à chaque fois différente.
    Ainsi la \emph{min-priority queue} n'est pas nécessaire, une simple
    \emph{queue} peut être utilisé.
    L'algorithme ressemble donc à un parcour en largeur (\emph{breadth-first})
    qui s'arrêtera au premier parking \emph{gagnant} rencontré. \newline

    Exemple en mettant en évidence les profondeurs du parcours: \newline
    \begin{tikzpicture}
        [scale=.8,auto=left,every node/.style={circle,fill=blue!20}]
        \node (n0) at (1, 10) {\includegraphics[scale=0.15]{gen0.png}};
        \node (n1) at (4, 10) {\includegraphics[scale=0.15]{gen1.png}};
        \node (n2) at (7, 10) {\includegraphics[scale=0.15]{gen2.png}};
        \node[color=green] (n3) at (10, 10) {\includegraphics[scale=0.15]{gen3.png}};
        % Premier win

        %Autre situation Ã  partir de n0
        \node (n4) at (1, 7) {\includegraphics[scale=0.13]{gen4.png}};
        \node (n5) at (2, 5) {\includegraphics[scale=0.13]{gen5.png}};
        \node (n6) at (4, 4) {\includegraphics[scale=0.13]{gen6.png}};
        \node (n7) at (7, 4) {\includegraphics[scale=0.13]{gen7.png}};
        \node (n8) at (10, 4) {\includegraphics[scale=0.13]{gen8.png}};
        \node (n9) at (13, 4) {\includegraphics[scale=0.13]{gen9.png}};

        \node (n10) at (13, 4) {\includegraphics[scale=0.13]{gen10.png}};

        \foreach \from/\to in {n0/n1, n1/n2, n2/n3, n0/n4, n4/n5, n5/n6, n6/n7,
        n7/n8, n8/n9}
        \draw (\from) -- (\to);
        \draw[color=red]  (1, 8) to[out=10,in=-90] (3, 10);
        \draw[color=red]  (1, 6) to[out=0,in=-85] (5, 10);
        \draw[color=red]  (3, 5) to[out=90,in=-85] (8, 10);
        \draw[color=red] (6, 4) to[out=90,in=-85] (11, 10);
    \end{tikzpicture}



\section{Optimisation}
Une optimisation possible pour l'algorithme est de combiner la génération des
configurations avec la recherche du plus court chemins. Pour chaque noeuds que
l'on traite de notre queue (en commençant par le premier), on générera toutes les
configurations possible à partir de là , et on ajoutera chacune des nouvelles
configurations à cette queue pour être traité plus tard. En traitant les noeuds
de cette façon, on fait aussi un parcours par couche (chaque couches génér la
suivante) mais on générera beaucoup moins de configuration puisqu'on va arrêter
d'en générer d'autres si on tombe sur une configuration gagnante.\\

Exemple du traitement des parkings par couches (les chiffres correspondent au
moment où le parking va être traité).\\

\begin{tikzpicture}
    [scale=.8,auto=left,every node/.style={circle,fill=blue!20}]
    \node (n0-0) at (1, 10) {1};
    \node (n0-1) at (3, 10) {2};
    \node (n0-2) at (5, 10) {4};
    \node (n0-3) at (7, 10) {7};
    % Premier win

    %Autre situation Ã  partir de n0
    \node (n1-0) at (3, 7) {3};
    \node (n1-1) at (5, 7) {6};
    \node[fill=red] (n1-2) at (7, 7) {10};

    \node (n1-1-0) at (5, 8) {7};
    \node (n1-1-1) at (7, 8) {8};

    \node (n1-1-0-0) at (7, 9) {8};

    \node (n2-0) at (5, 8) {5};

    \node (n2-1) at (7, 8) {9};

    \node (n1-1-2) at (7, 6) {11};

    \foreach \from/\to in {n0-0/n0-1, n0-1/n0-2, n0-2/n0-3,
                           n0-0/n1-0,
                           n1-0/n1-1, n1-1/n1-2,
                           n1-0/n1-1-0, n1-1-0/n1-1-1,
                           n1-1/n1-1-2,
                           n1-1-0/n1-1-0-0}
    \draw (\from) -- (\to);
    \draw[dashed] (8, 10) -- (9, 10);
    \draw[dashed] (8, 9) -- (9, 9);
    \draw[dashed] (8, 8) -- (9, 8);
\end{tikzpicture}

\begin{algorithm}[H]
    \KwData{currentParking = baseParking;}
    \KwResult{shortestParkingPath;}
    \While{Queue.isNotEmpty() \emph{AND} currentParking.isNotWin() } {
        carList = currentParking.move\_each\_car\_forward();
        carList.append\_if\_not\_already\_threated();

        carList = currentParking.move\_each\_car\_backward();
        carList.append\_if\_not\_already\_threated();

        currentParking = Queue.pop()
    }
    \caption{Pseudo code de l'algorithme}
\end{algorithm}

\section{Optimisation possible}
Une optimisation possible du problême est de ne pas seulement considérer les
déplacements \emph{d'une case} mais aussi les mouvements de plusieurs cases
(sur les lignes des voitures). De cette façon on peut générer moins de cas.
Le problême est qu'avec cette optimisation on génère moins de cas seulement si pour
résoudre le problême il faut faire avancer deux fois ou plus une voiture sur sa
ligne, sinon le nombre d'opération dans l'algorithme sera plus élevé.
\section{Fichier output}
La solution trouvée sera affiché en ligne de commande, comme affiché dans la section "Cas de base". Mais aussi dans un fichier .txt nommé Solution.txt dont voici quelque exemple:


THOMAS AJOUTE LE FICHIER SOLUTION.TXT DANS UN CARRé.
MAIS RAJOUTE AUSSI SIL TE PLAIT L'EXEMPLE DU FICHIER TEST2 OU IL N'Y A PAS DE POSSIBILITé

\begin{thebibliography}
\indent Mark Stamp, Brad Engel McIntosh Ewekk, Victor Morrow,\emph{Rush Hour and Dijkstra's algorithm} http://www.cs.sjsu.edu/~stamp/cv/papers/rh.pdf.

\end{thebibliography}

\end{document}
