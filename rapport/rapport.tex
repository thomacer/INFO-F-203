\documentclass[10pt, a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{PERALE Thomas et RUSU George}
\rhead{INFO-F-203}

\usepackage{graphicx}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage[]{algorithm2e}
\usepackage{indentfirst}

\begin{document}
\title{Rapport projet d'algorithmique 2}
\author{PERALE Thomas (000408160)\\
        RUSU George (000407965)\\}
\date{le 1 décembre 2015}

\maketitle
\section{Introduction}
Dans le parking d'un centre commercial, Mademoiselle Goal désire sortir
sa voiture le plus rapidement possible en exécutant le moins de manoeuvre
possible. Evidemment le parking n'est pas vide, alors Mademoiselle Goal
demande à ses amis les informaticiens de l'aider. Notre but et de trouver
à l'aide de graphe (un noeud du graphe représente une configuration du parking)
le plus court chemin (le moins de manoeuvre possible)
pour d'aider Mademoiselle Goal à rentrer chez elle.

\section{Cas de base}
Notre parking est un tableau n x n dans lequel plusieurs voiture s'y trouve.
Parmi ces voitures, la voiture de Mlle (noté "G").
Dans ce tableau, chaque cases peut contenir une parite de voiture (elles
occupent  deux cases).
Il faut savoir qu'une voiture peut avancer ou reculer selon son orientation
(verticale ou horizontale) jusqu'à la limite du tableau.
L'unique voiture qui a le droit de sortir du tableau est bien évidemment
la voiture Goal.

\indent Toutes les information nécessaire à l'algorithme sont dans un fichier
que notre programme reçoit en argument. \newline
\indent Voici un exemple de fichier:
    \lstinputlisting{../test/test1.txt}
    Celui ci nous renseigne sur:
    \begin{itemize}
        \item La taille du parking.
        \item La position de la sortie.
        \item L'emplacement des voitures dans ce parking.
    \end{itemize}
    Toute ces informations vont être parsées pour pouvoir créer un parking initial, qui sera notre
    cas de base à partir duquel il va falloir trouver le plus court chemin.\\
    Conformément à l'énoncé, l'algorithme ne fonctionnera que dans les cas suivant:
        \begin{itemize}
        \item Le fichier d'input est correctement écrit (pas d'erreur dans celui-ci), de la même manière que dans l'exemple.
        \item La voiture goal se déplace horizontalement (la sortie est sur la
            droite ou la gauche).
        \item Il n'y a pas de voiture de taille 1 (car impossible de savoir si
            elle se déplace horizontalement ou verticalement).
        \item Parking de taille supérieure ou égale à 2.
    \end{itemize}

\section{Exemple d'utilisation.}
Exemple de réseultat en utilisant l'exemple de fichier au dessus passé en
argument. \newline
\indent En utilisant la commande ci-dessous une fois le programme compilé avec \emph{make}:
\begin{lstlisting}
java -cp .:./src RushHour ./test/test1.txt
\end{lstlisting}

\begin{lstlisting}
+---+---+---+---+---+
|     V2  V2        |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
| G   G   V3  V4
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|                   |
+---+---+---+---+---+

+---+---+---+---+---+
| V2  V2            |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
| G   G   V3  V4
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|                   |
+---+---+---+---+---+

+---+---+---+---+---+
| V2  V2  V3        |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
| G   G       V4
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|                   |
+---+---+---+---+---+

+---+---+---+---+---+
| V2  V2  V3        |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
|     G   G   V4
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|                   |
+---+---+---+---+---+

+---+---+---+---+---+
| V2  V2  V3        |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
|     G   G
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|             V4    |
+---+---+---+---+---+

+---+---+---+---+---+
| V2  V2  V3        |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
|         G   G
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|             V4    |
+---+---+---+---+---+

+---+---+---+---+---+
| V2  V2  V3        |
+   +   +   +   +   +
|         V3        |
+   +   +   +   +   +
|             G   G
+   +   +   +   +   +
|             V4    |
+   +   +   +   +   +
|             V4    |
+---+---+---+---+---+
\end{lstlisting}

\section{Description de la résolution du problème.}
    Le problème va se faire en plusieurs étapes:
    \begin{enumerate}
        \item Générer toutes les configurations\footnote{Une configuration d'un
            parking est un parking où chaque voiture a une position possible.
            À chaque tour, une voiture bougera dans le parking, c'est pour cette
            raison qu'on parle de configuration différente.} de parking
            possible.
        \item Lors de cette génération, créer un graphe dans lequel chaque
            configuration nouvellement créé est lié à la configuration d'où elle vient.
        \item Une fois ces configurations générées, il suffit d'appliquer un algorithme de
            recherche du plus court chemin sur le graphe dont les noeud sont des configurations.
    \end{enumerate}

   Exemple\footnote{Les exemples sont créés à  partir de
    http://analogbit.com/software/puzzletools/ .} de graphe associé aux
    configurations lors d'une génération non exhaustive (on aboutit à  deux
    situations gagnantes).

    % \includegraphics[scale=0.2]{gen0.png} \newline
    % \newpage
    \begin{tikzpicture}
        [scale=.8,auto=left,every node/.style={circle,fill=blue!20}]
        \node (n0) at (1, 10) {\includegraphics[scale=0.15]{gen0.png}};
        \node (n1) at (4, 10) {\includegraphics[scale=0.15]{gen1.png}};
        \node (n2) at (7, 10) {\includegraphics[scale=0.15]{gen2.png}};
        \node (n3) at (10, 10) {\includegraphics[scale=0.15]{gen3.png}};
        % Premier win

        %Autre situation Ã  partir de n0
        \node (n4) at (1, 7) {\includegraphics[scale=0.13]{gen4.png}};
        \node (n5) at (2, 5) {\includegraphics[scale=0.13]{gen5.png}};
        \node (n6) at (4, 4) {\includegraphics[scale=0.13]{gen6.png}};
        \node (n7) at (7, 4) {\includegraphics[scale=0.13]{gen7.png}};
        \node (n8) at (10, 4) {\includegraphics[scale=0.13]{gen8.png}};
        \node (n9) at (13, 4) {\includegraphics[scale=0.13]{gen9.png}};

        \node (n10) at (13, 4) {\includegraphics[scale=0.13]{gen10.png}};

        \foreach \from/\to in {n0/n1, n1/n2, n2/n3, n0/n4, n4/n5, n5/n6, n6/n7,
        n7/n8, n8/n9}
        \draw (\from) -- (\to);
    \end{tikzpicture}

\subsection{Génération des configurations.}
    Pour générer l'ensemble des solutions, un algorithme de backtracking est
    utilisé. Celui-ci fait avancer ou reculer un maximum chaque voiture pour
    chaque configuration.
    \subsection{Recherche du plus court chemin.}
    Pour trouver le plus court chemin parmi ceux déjà générés, on peut
    utiliser l'algorithme le plus évident: \emph{l'algorithme de Dijkstra}.
    Or ici, nous avons un cas spécial de l'algorithme de Dijkstra car
    la distance entre chaque noeuds est de 1, et l'algorithme fait une
    recherche dans un graphe où la distance entre deux noeuds est à 
    chaque fois différente.\newline
    Ainsi la \emph{min-priority queue} n'est pas nécessaire, une simple
    \emph{queue} peut être utilisé.
    L'algorithme ressemble donc à un parcour en largeur (\emph{breadth-first})
    qui s'arrêtera au premier parking \emph{gagnant} rencontré. \newline

    Exemple en mettant en évidence les profondeurs du parcours: \newline
    \begin{tikzpicture}
        [scale=.8,auto=left,every node/.style={circle,fill=blue!20}]
        \node (n0) at (1, 10) {\includegraphics[scale=0.15]{gen0.png}};
        \node (n1) at (4, 10) {\includegraphics[scale=0.15]{gen1.png}};
        \node (n2) at (7, 10) {\includegraphics[scale=0.15]{gen2.png}};
        \node[color=green] (n3) at (10, 10) {\includegraphics[scale=0.15]{gen3.png}};
        % Premier win

        %Autre situation Ã  partir de n0
        \node (n4) at (1, 7) {\includegraphics[scale=0.13]{gen4.png}};
        \node (n5) at (2, 5) {\includegraphics[scale=0.13]{gen5.png}};
        \node (n6) at (4, 4) {\includegraphics[scale=0.13]{gen6.png}};
        \node (n7) at (7, 4) {\includegraphics[scale=0.13]{gen7.png}};
        \node (n8) at (10, 4) {\includegraphics[scale=0.13]{gen8.png}};
        \node (n9) at (13, 4) {\includegraphics[scale=0.13]{gen9.png}};

        \node (n10) at (13, 4) {\includegraphics[scale=0.13]{gen10.png}};

        \foreach \from/\to in {n0/n1, n1/n2, n2/n3, n0/n4, n4/n5, n5/n6, n6/n7,
        n7/n8, n8/n9}
        \draw (\from) -- (\to);
        \draw[color=red]  (1, 8) to[out=10,in=-90] (3, 10);
        \draw[color=red]  (1, 6) to[out=0,in=-85] (5, 10);
        \draw[color=red]  (3, 5) to[out=90,in=-85] (8, 10);
        \draw[color=red] (6, 4) to[out=90,in=-85] (11, 10);
    \end{tikzpicture}



\section{Optimisation}
Une optimisation choisie pour l'algorithme est de combiner la génération des
configurations avec la recherche du plus court chemins. Pour chaque noeud que
l'on traite de notre queue (en commençant par le cas de base), on générera toutes les
configurations possible, et on les ajoutera
à cette queue pour être traité plus tard. En traitant les noeuds
de cette façon, on fait un parcours par couche (chaque couche génère la
suivante) mais on va génerer beaucoup moins de configurations car
la génération des noeuds suivants se fait par couche.

Exemple du traitement des parkings par couches (les chiffres correspondent au
moment où le parking va être traité et les \emph{"\ldots"} montre qu'on a
généré une étape en plus).\\

\begin{tikzpicture}
    [scale=.8,auto=left,every node/.style={circle,fill=blue!20}]
    \node (n0-0) at (1, 10) {1};
    \node (n0-1) at (3, 10) {2};
    \node (n0-2) at (5, 10) {4};
    \node (n0-3) at (7, 10) {7};
    % Premier win

    %Autre situation Ã  partir de n0
    \node (n1-0) at (3, 7) {3};
    \node (n1-1) at (5, 7) {6};
    \node[fill=red] (n1-2) at (7, 7) {10};

    \node (n1-1-0) at (5, 8) {7};
    \node (n1-1-1) at (7, 8) {8};

    \node (n1-1-0-0) at (7, 9) {8};

    \node (n2-0) at (5, 8) {5};

    \node (n2-1) at (7, 8) {9};

    \node (n1-1-2) at (7, 6) {11};

    \foreach \from/\to in {n0-0/n0-1, n0-1/n0-2, n0-2/n0-3,
                           n0-0/n1-0,
                           n1-0/n1-1, n1-1/n1-2,
                           n1-0/n1-1-0, n1-1-0/n1-1-1,
                           n1-1/n1-1-2,
                           n1-1-0/n1-1-0-0}
    \draw (\from) -- (\to);
    \draw[dashed] (8, 10) -- (9, 10);
    \draw[dashed] (8, 9) -- (9, 9);
    \draw[dashed] (8, 8) -- (9, 8);
\end{tikzpicture}

\begin{algorithm}[H]
    \KwData{currentParking = baseParking;}
    \KwData{Queue.add(baseParking);}
    \While{Queue.isNotEmpty() \emph{AND} currentParking.isNotWin() } {
        carList = currentParking.move\_each\_car\_forward();
        Queue.append\_if\_not\_already\_threated(carList);

        carList = currentParking.move\_each\_car\_backward();
        Queue.append\_if\_not\_already\_threated(carList);

        currentParking = Queue.pop()
    }
    \KwResult{shortestParkingPath;}
    \caption{Pseudo code de l'algorithme}
\end{algorithm}

\section{Optimisation possible}
Une optimisation possible du problême est de ne pas seulement considérer les
déplacements \emph{d'une case} mais aussi les mouvements de plusieurs cases
(sur les lignes des voitures). De cette façon on peut générer moins de cas.
Le problême est qu'avec cette optimisation on génère moins de cas seulement si pour
résoudre le problême il faut faire avancer deux fois ou plus une voiture sur sa
ligne, sinon le nombre d'opération dans l'algorithme sera plus élevée.
\section{Fichier output}
La solution trouvée sera affiché en ligne de commande, comme affiché dans la section "Cas de base". Mais aussi dans un fichier .txt nommé Solution.txt dont voici quelque exemple:


THOMAS AJOUTE LE FICHIER SOLUTION.TXT DANS UN CARRé.
MAIS RAJOUTE AUSSI SIL TE PLAIT L'EXEMPLE DU FICHIER TEST2 OU IL N'Y A PAS DE POSSIBILITé

\begin{thebibliography}
\indent Mark Stamp, Brad Engel McIntosh Ewekk, Victor Morrow,\emph{Rush Hour
and Dijkstra's algorithm} \url{http://www.cs.sjsu.edu/~stamp/cv/papers/rh.pdf}.
\newline
\indent Bernard Fortz,  Olivier Markowitch, \emph{Algorithme 2}
\url{https://dochub.be/document/dl/68} \newline
\end{itemize}
\end{thebibliography}

\end{document}
